/*
 ************************************************************************************
 * Copyright (C) 2013-2013 Openbravo S.L.U.
 * Licensed under the Openbravo Commercial License version 1.0
 * You may obtain a copy of the License at http://www.openbravo.com/legal/obcl.html
 * or in the legal folder of this module distribution.
 ************************************************************************************
 */
/*global console, enyo, scan, exports */

/*
  Information about TestRegistry

  TestRegistry initializes when a webpage is loaded
  The content is lazy loaded so it does not consum any resources until invoqued the first time
  Each time the url (window.location) changes, the TestRegistry resets its content

  Good practices in the enyo components for the TestRegistry to work properly are:
    - follow the nomenclator rule
    - in the enyo.kind definition add the 'id' keyword and use the nomenclator rule, e.g: "id: 'OB.UI.id.myEnyoControl'"
    - if the id is not added, be sure that the enyo.kind name is properly set and follow the nomenclator rules
*/


// for the sake of compatibility
if (!Array.prototype.forEach) {
  Array.prototype.forEach = function (fn, scope) {
    var i, len;
    for (i = 0, len = this.length; i < len; ++i) {
      fn.call(scope, this[i], i, this);
    }
  };
}


(function () {
  // TestRegistry allows to find and test ui objects
  // the OBid is the identifier that TestRegistry needs to work
  // its taken from the enyo.id; if the id has a '_' means that the enyo has generated it, so the enyo.name is taken
  var root = this,
      QualityEnum;

  var TestRegistry;

  // CommonJS modules
  if (typeof exports !== 'undefined') {
    TestRegistry = exports;
  } else {
    TestRegistry = root.TestRegistry = {};
  }

  TestRegistry.VERSION = '0.4.18';

  console.log('TestRegistry %s is available', TestRegistry.VERSION);

  QualityEnum = {
    UNKNOWN: 0,
    ENYO_GENERATED: -2,
    // this is the lowest level. Enyo auto generates an id for every object if the id is not explicitly defined
    ENYO_NAME: 1,
    // if the enyo did autogenerate the id, we replace the id with the name of the enyo object
    ENYO_ID: 2,
    // the develper explicitly defined the id
    OB_ID: 3 // the developer explicitly defined the id and followed the nomenclator rules. this is best practice.
  };

  var nomenclatorRoot = 'org.openbravo.';
  var verbose = false;
  var scannedUrl = '';
  var registeredObjects = null;
  var minimumQualityToBeAproved = QualityEnum.ENYO_ID;

  var listOfProtectedStartsWithStrings = [
  // DEVELOPER: add here the list of strings that you will not use to start a kindName. E.g: "control" for "control4"
  'floatingLayer', 'control', 'image', 'scrim'];

  function RegisterObject(id, OBid) {
    var qualityText, getList;
    this.id = id;
    this.OBid = OBid;
    this.quality = QualityEnum.UNKNOWN; // 0: unknown, -2: the id has been generated by enyo, -1: the id is taken from the enyo.name, 1: the id is valid, 2: follows nomenclator
    // infer quality
    // all the ids should follow some nomenclator, e.g. nomenclatorRoot.xxx
    if (OBid === undefined) {
      this.quality = QualityEnum.ENYO_GENERATED;
      this.OBid = this.id;
      if (this.OBid.indexOf('_') >= 0) { // if the id was generated by enyo, ignore it
        this.quality = QualityEnum.ENYO_NAME;
        this.OBid = enyo.$[id].name;
      } else {
        this.OBid = enyo.$[id].id;
        this.quality = QualityEnum.ENYO_ID;
        if (enyo.$[id].id.indexOf(nomenclatorRoot) >= 0) {
          this.quality = QualityEnum.OB_ID;
        }
      }
    }

    this.enyoObject = enyo.$[this.id];
    this.DOMObject = document.getElementById(this.id);
    this.isOBidRepeated = false;
  }


  function qualityText(row) {
    var vqualityText = '';
    switch (row.quality) {
    case QualityEnum.ENYO_GENERATED:
      vqualityText = 'enyo.id auto';
      break;
    case QualityEnum.ENYO_NAME:
      vqualityText = 'enyo.name';
      break;
    case QualityEnum.UNKNOWN:
      vqualityText = 'unknown';
      break;
    case QualityEnum.ENYO_ID:
      vqualityText = 'enyo.id';
      break;
    case QualityEnum.OB_ID:
      vqualityText = 'OB approved';
      break;
    default:
      OB.error('type ' + row.quality + ' quality is missing. Fix it.');
    }
    return vqualityText;
  }

  RegisterObject.prototype.toString = function () {
    return '(' + qualityText(this) + ')' + (this.isOBidRepeated ? ' (repeated)' : '') + ' {OBid: ' + this.OBid + (this.enyoObject ? (', kindName: ' + this.enyoObject.kindName) : '') + ', id: ' + this.id + '}';
  };

  function getList() {
    // 'lazy load' function that contains all the enyo objects in the webpage
    if (scannedUrl !== window.location.href) {
      registeredObjects = null;
    }
    if (registeredObjects === null) {
      OB.info('lazy loading...');
      registeredObjects = [];
      scannedUrl = window.location.href;
      scan();
      OB.info('... lazy load complete');
    }

    return registeredObjects;
  }

  function findWhere(OBid) {
    // finds the register with the specified OBid
    var list = getList();
    var found = null;
    list.some(function (element, index, array) {
      if (element.OBid === OBid) {
        if (found) {
          if (Object.prototype.toString.call(found) !== '[object Array]') {
            found = [found];
          }
          found.push(element);
        } else {
          found = element;
        }
      }
    });
    return found;
  }

  function addToTheList(row) {
    // adds a new register to the list of objects found in the webpage
    // more elements can be added with the register function
    if (verbose) {
      OB.info('Adding ' + row.toString());
    }

    var list = getList();

    // if the OBid if duplicated, mark both registers as isOBidRepeated
    list.some(function (element, index, array) {
      if (element.OBid === row.OBid) {
        element.isOBidRepeated = true;
        row.isOBidRepeated = true;
        return true;
      }
    });

    list.push(row);
  }

  function mustBeFiltered(OBid) {
    // returns true if the OBid starts with one of the strings in the getListOfProtectedStartsWithStrings
    return listOfProtectedStartsWithStrings.some(function (element, index, array) {
      return OBid.indexOf(element) === 0;
    });
  }

  function scan() {
    // scan the loaded web page registering all the enyo elements found
    // if TestRegistry is not registering your object, you might find here the reason
    var validObjects = 0,
        objects = 0,
        enyoObject;

    for (enyoObject in enyo.$) {
      if (enyo.$.hasOwnProperty(enyoObject)) {
        objects += 1;
        if (enyo.$[enyoObject] === null) {
          if (verbose) {
            OB.info(' id: ' + enyoObject + ' is null... suspiciously null');
          }
        } else {
          validObjects += 1;
          var row = new RegisterObject(enyoObject);
          // apply filter
          if (mustBeFiltered(row.OBid)) {
            if (verbose) {
              OB.error("the 'name:' for this enyo object (id:" + row.id + ") has not been set");
            }
          } else {
            addToTheList(row);
          }
        }
      }
    }
    var list = getList();

    OB.info('   Scanned: ' + scannedUrl);
    OB.info('   Objects: ' + objects + ', valid objects: ' + validObjects + ', Registered: ' + list.length);
  }

  TestRegistry.getListOfProtectedStartsWithStrings = function () {
    // returns a pointer to the list of the keywords that will be skipped if are found at the beginning of the id
    return listOfProtectedStartsWithStrings;
  };

  TestRegistry.getCountOfRegisteredObjects = function () {
    // returns information about the registered objects
    // this function is not intended to be used but to be informative while creating the tests
    // if you require this numbers in your tests, you should write a better refactored version
    var list = getList();
    var properlyRegistered = list.filter(function (row) {
      return !row.isOBidRepeated;
    }).length;
    var improperlyRegistered = list.filter(function (row) {
      return row.isOBidRepeated;
    }).length;
    var qualityUnknown = list.filter(function (row) {
      return row.quality === QualityEnum.UNKNOWN;
    }).length;
    var qualityEnyoGenerated = list.filter(function (row) {
      return row.quality === QualityEnum.ENYO_GENERATED;
    }).length;
    var qualityEnyoName = list.filter(function (row) {
      return row.quality === QualityEnum.ENYO_NAME;
    }).length;
    var qualityEnyoId = list.filter(function (row) {
      return row.quality === QualityEnum.ENYO_ID;
    }).length;
    var qualityOBId = list.filter(function (row) {
      return row.quality === QualityEnum.OB_ID;
    }).length;
    var approved = list.filter(function (row) {
      return row.quality >= minimumQualityToBeAproved;
    }).length;

    return {
      total: getList().length,
      properlyRegistered: properlyRegistered,
      improperlyRegistered: improperlyRegistered,
      unknown: qualityUnknown,
      enyoGenerated: qualityEnyoGenerated,
      enyoName: qualityEnyoName,
      enyoID: qualityEnyoId,
      definedOBid: qualityOBId,
      approved: approved
    };
  };

  TestRegistry.registry = function (OBid) {
    var obj = findWhere(OBid);
    if (obj === null) {
      OB.error("Cannot find any object with OBid = '" + OBid + "'");
      return null;
    }
    if (obj.isOBidRepeated || (obj[0] && obj[0].isOBidRepeated)) {
      OB.error("'" + OBid + "' is repeated, fix it before use it");
    }
    return obj;
  };

  TestRegistry.register = function (OBid, id, content) {
    var row = new RegisterObject(id, OBid);
    addToTheList(row);
  };

  TestRegistry.findById = function (id) {
    // finds the registered object with a DOM id
    var list = getList();
    var found = null;
    list.some(function (element, index, array) {
      if (element.id === id) {
        found = element;
        return true;
      }
    });
    return found;
  };

  function printArray(array) {
    if (!array) {
      return;
    }

    array.sort();
    array.reverse();
    array.forEach(function (element, index) {
      OB.info(index + '. ' + element.toString());
    });
  }

  function printWithQualityFilter(quality) {
    var list = getList();

    var la = list.filter(function (element, index) {
      return element.quality >= quality;
    });

    printArray(la);
  }

  function printWithRepeatedFilter(isOBidRepeated) {
    var list = getList();

    var la = list.filter(function (element, index) {
      return element.isOBidRepeated === isOBidRepeated;
    });

    printArray(la);
  }

  TestRegistry.getRegisters = function () {
    // returns the list of enyo objects found in the page along with the objects registered with the register function
    return getList();
  };

  TestRegistry.getApprovedRegisters = function () {
    // returns the list of objects that you should use in the tests. yes, no others.
    var list = getList();
    var approved = [];
    list.forEach(function (element, index) {
      if (!element.isOBidRepeated && element.quality >= QualityEnum.ENYO_NAME) {
        approved.push(element);
      }
    });
    return approved;
  };

  TestRegistry.printAllRegisteredObjects = function () {
    OB.info('Registered objects');
    printWithRepeatedFilter(true);
    printWithRepeatedFilter(false);
  };

  TestRegistry.printApprovedObjects = function () {
    // prints the list of objects that are approved
    // these are the only objects that should be used
    OB.info('Approved objects'); // (' + list.length + ')');
    printArray(this.getApprovedRegisters());
  };

  TestRegistry.printProperlyRegisteredObjects = function () {
    // prints the list of objects that are properly registered
    // properly registered does not mean that should be used
    // check printApprovedObjects for the list of objects that can be used
    OB.info('Properly registered objects'); // (' + list.length + ')');
    printWithRepeatedFilter(false);
  };

  TestRegistry.printImproperlyRegisteredObjects = function () {
    // prints the list of names that need some love before being usable
    OB.info('Improperly registered objects');
    printWithRepeatedFilter(true);
  };

  function printToConsole(isOBidRepeated) {
    var list = getList();
    list.forEach(function (row, index) {
      if (isOBidRepeated === null || row.isOBidRepeated === isOBidRepeated) {
        OB.info(index + '. ' + row.toString());
      }
    });
  }

  TestRegistry.clear = function () {
    // clears the registered objects' list
    registeredObjects = null;
    OB.info('TestRegistry cleared');
  };

  TestRegistry.enyoObject = function (OBid) {
    // returns the object as an enyo object
    var id = findWhere(OBid).id;
    return enyo.$[id];
  };

  TestRegistry.DOMObject = function (OBid) {
    // returns the html code of the object
    var id = findWhere(OBid).id;
    return document.getElementById(id);
  };

  TestRegistry.scannedUrl = function () {
    // returns the url of which the objects have been retrieved
    // when this url changes, the list of registered objects is recreated
    return scannedUrl;
  };

  TestRegistry.selfTest = function () {
    // Run some tests to the TestRegistry itself to check if it's working as expected
    if (window.location.toString().indexOf('#login') < 0) {
      OB.info('run this tests in the POS login page');
      return;
    }

    this.printAllRegisteredObjects();
    this.printApprovedObjects();
    this.printProperlyRegisteredObjects();
    this.printImproperlyRegisteredObjects();

    this.register('myOBid', 'myDOMid');

    var row = this.registry('terminal');
    if (row === null) {
      OB.error("FAIL: this.registry('terminal')");
      return;
    }
    OB.info(row.enyoObject);
    OB.info(row.DOMObject);

    row = this.registry('username');
    console.assert(row !== null, "OBid = 'username' not found");
    if (row === null) {
      OB.error("FAIL: this.registry('username')");
      return;
    }
    row.enyoObject.setValue('vallblanca');

    row = this.registry('password');
    if (row === null) {
      OB.error("FAIL: this.registry('password')");
      return;
    }
    row.enyoObject.setValue('openbravo');

    row = this.registry('loginButton');
    if (row === null) {
      OB.error("FAIL: this.registry('loginButton')");
      return;
    }

    if (this.registry('myOBid') === null) {
      OB.error("FAIL: custom registers are not being registered");
      return;
    }

    setTimeout(function () {
      row.enyoObject.bubble('ontap');
      return 'PASSED';
    }, 2000);

  };

  TestRegistry.help = function () {
    OB.info('List of TestRegistry properties:');
    var publicProperties = Object.getOwnPropertyNames(this);
    publicProperties.sort();
    publicProperties.forEach(function (element, index) {
      OB.info('  - ' + element);
    });
  };
}());